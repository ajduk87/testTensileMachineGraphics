/////////////////////////////////////////////////////////////////////
//
//	PdfFileWriter
//	PDF File Write C# Class Library.
//
//	PdfObject
//	Base class for all PDF indirect object classes.
//
//	Granotech Limited
//	Author: Uzi Granot
//	Version: 1.0
//	Date: April 1, 2013
//	Copyright (C) 2013-2014 Granotech Limited. All Rights Reserved
//
//	PdfFileWriter C# class library and TestPdfFileWriter test/demo
//  application are free software.
//	They is distributed under the Code Project Open License (CPOL).
//	The document PdfFileWriterReadmeAndLicense.pdf contained within
//	the distribution specify the license agreement and other
//	conditions and notes. You must read this document and agree
//	with the conditions specified in order to use this software.
//
//	Version History:
//
//	Version 1.0 2013/04/01
//		Original revision
//	Version 1.1 2013/04/09
//		Allow program to be compiled in regions that define
//		decimal separator to be non period (comma)
//	Version 1.2 2013/07/21
//		The original revision supported image resources with
//		jpeg file format only.
//		Version 1.2 support all image files acceptable to Bitmap class.
//		See ImageFormat class. The program was tested with:
//		Bmp, Gif, Icon, Jpeg, Png and Tiff.
//	Version 1.3 2014/02/07
//		Fix bug in PdfContents.DrawBezierNoP2(PointD P1, PointD P3)
//	Version 1.4 2014/03/01
//		PdfContents
//		Add method: public void TranslateScaleRotate(Double OrigX,
//			Double OrigY, Double ScaleX, Double ScaleY, Double Rotate);
//		Add method: public String ReverseString(Strint Text);
//		Fix some problems with DrawXObject(...); methods
//		PdfFont
//		Extensive changes to font substitution (see article)
//		PdfImage
//		Add method: public SizeD ImageSizeAndDensity(Double Width,
//			Double Height, Double Density);
//		This method controls the size of the bitmap (see article)
//		Add method: public void SetImageQuality(Int32 ImageQuality);
//		This method controls the image quality (see article)
//		PdfTilingPattern
//		Fix bug in public static PdfTilingPattern SetWeavePattern(...);
//	Version 1.5 2014/05/05
//		Add barcode feature. Supported barcodes are:
//		Code-128, Code39, UPC-A, EAN-13
//	Version 1.6 2014/07/09
//		Fix FontApi unanaged code resource disposition.
//		Clear PdfDocument object after CreateFile.
//	Version 1.7 2014/08/25
//		Add encryption support
//		Add Web link support
//		Add QRCode support
//		Change compression to .net System.io.compression
//
/////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Text;

namespace PdfFileWriter
{
/////////////////////////////////////////////////////////////////////
// Resource code enumeration
/////////////////////////////////////////////////////////////////////

internal enum ResCode
	{
	// must be in this order
	Font,
	Pattern,
	Shading,
	XObject,
	Length
	}

////////////////////////////////////////////////////////////////////
// PdfObject Class
// PDF indirect object base class
// User program cannot call it directly
////////////////////////////////////////////////////////////////////

public class PdfObject : IComparable<PdfObject>
	{
	internal	PdfDocument			Document;			// PDF parent document
	internal	Int32				ObjectNumber;		// PDF indirect object number
	internal	String				ResourceCode;		// resource code automatically generated by the program
	internal	Int32				FilePosition;		// PDF file position for this indirect object
	internal	StringBuilder		ContentsString;		// contents objects commands (page contents, X objects and tiling patterns)
	protected	Double				ScaleFactor;		// scale factor from user unit of measure to points
	private		List<PdfDictionary> Dictionary;			// indirect objects dictionary or stream dictionary

	private  static String[]		ResCodeStr = {"/Font <<", "/Pattern <<", "/Shading <<", "/XObject <<"};
	internal static String			ResCodeLetter = "FPSX";

	////////////////////////////////////////////////////////////////////
	// Constructor for objects with no /Type in their dictionary
	// Note: access is internal. Used by derived classes only
	////////////////////////////////////////////////////////////////////

	internal PdfObject
			(
			PdfDocument	Document,		// link to PdfDocument the main class
			Boolean		Stream			// true if the indirect object is a stream, false otherwise
			) : this(Document, Stream, null) {}

	////////////////////////////////////////////////////////////////////
	// Constructor for objects with /Type in their dictionary
	// Note: access is internal. Used by derived classes only
	////////////////////////////////////////////////////////////////////

	internal PdfObject
			(
			PdfDocument	Document,		// link to PdfDocument the main class
			Boolean		Stream,			// true if the indirect object is a stream, false otherwise
			String		ObjectType		// object type (i.e. /Catalog, /Pages, /Font, /XObject)
			)
		{
		// save link to main document object
		this.Document = Document;

		// save scale factor
		ScaleFactor = Document.ScaleFactor;

		// if object is stream define empty dictionary and empty contents stream
		if(Stream)
			{
			Dictionary = new List<PdfDictionary>();
			ContentsString = new StringBuilder();
			}

		// set PDF indirect object number to next available number
		this.ObjectNumber = Document.ObjectArray.Count + 1;

		// if object name is specified, create a dictionary and add /Type Name entry
		if(!String.IsNullOrEmpty(ObjectType)) AddToDictionary("/Type", ObjectType);

		// add the new object to object array
		Document.ObjectArray.Add(this);
		return;
		}

	////////////////////////////////////////////////////////////////////
	// Compare the resource codes of two PDF objects
	// Used by PdfContents to maintain resource objects in sorted order.
	////////////////////////////////////////////////////////////////////

	public Int32 CompareTo
			(
			PdfObject Other		// the second object
			)
		{
		return(String.Compare(this.ResourceCode, Other.ResourceCode));
		}

	////////////////////////////////////////////////////////////////////
	// Convert user coordinates or line width to points.
	// The result is rounded to 6 decimal places and converted to Single.
	////////////////////////////////////////////////////////////////////

	internal Single ToPt
			(
			Double	Value		// coordinate value in user unit of measure
			)
		{
		return((Single) Math.Round(ScaleFactor * Value, 6, MidpointRounding.AwayFromZero));
		}

	////////////////////////////////////////////////////////////////////
	// Round unscaled numbers.
	// The value is rounded to 6 decimal places and converted to Single
	////////////////////////////////////////////////////////////////////

	internal Single Round
			(
			Double	Value		// a number to be saved in contents
			)
		{
		return((Single) Math.Round(Value, 6, MidpointRounding.AwayFromZero));
		}

	////////////////////////////////////////////////////////////////////
	// Find key value pair in dictionary.
	// return index number or -1 if not found.
	////////////////////////////////////////////////////////////////////
	
	internal Int32 FindKeyInDictionary
			(
			String		Key		// key (first character must be forward slash /)
			)
		{
		// make sure dictionary is defined
		if(Dictionary != null)
			{
			// look through the dictionary
			for(Int32 Index = 0; Index < Dictionary.Count; Index++) if(Dictionary[Index].Key == Key) return(Index);
			}

		// no dictionary or not found
		return(-1);
		}

	////////////////////////////////////////////////////////////////////
	// Add key value pair to dictionary.
	// If dictionary does not exist, create it.
	// If key is not found, add the pair as new entry.
	// If key is found, replace old pair with new one.
	////////////////////////////////////////////////////////////////////
	
	internal void AddToDictionary
			(
			String		Key,	// key (first character must be forward slash /)
			String		Value	// value
			)
		{
		// create dictionary if not defined
		if(Dictionary == null) Dictionary = new List<PdfDictionary>();

		// search for existing key
		Int32 Index = FindKeyInDictionary(Key);

		// not found
		if(Index < 0)
			// add new pair
			Dictionary.Add(new PdfDictionary(Key, Value));

		// found
		else
			// replace value
			Dictionary[Index].Value = Value;

		// exit
		return;
		}

	////////////////////////////////////////////////////////////////////
	// Add key value pair to dictionary.
	// The value is a reference to indirect object number.
	// If dictionary does not exist, create it.
	// If key is not found, add the pair as new entry.
	// If key is found, replace old pair with new one.
	////////////////////////////////////////////////////////////////////
	
	internal void AddToDictionary
			(
			String		Key,	// key (first character must be forward slash /)
			PdfObject	Obj		// PdfObject. The method creates an indirect reference "n 0 R" to the object.
			)
		{
		AddToDictionary(Key, String.Format("{0} 0 R", Obj.ObjectNumber));
		return;
		}

	////////////////////////////////////////////////////////////////////
	// Get dictionary value
	// Return String if key is found, null if not
	////////////////////////////////////////////////////////////////////
	
	internal String GetDictionaryValue
			(
			String		Key		// key (first character must be forward slash /)
			)
		{
		Int32 Index = FindKeyInDictionary(Key);
		return(Index >= 0 ? Dictionary[Index].Value : null);
		}

	////////////////////////////////////////////////////////////////////
	// Convert resource dictionary to one String.
	// This method is called at the last step of document creation
	// from within PdfDocument.CreateFile(FileName).
	// it is relevant to page contents, X objects and tiled pattern
	// Return value is resource dictionary string.
	////////////////////////////////////////////////////////////////////
	
	internal String BuildResourcesDictionary
			(
			List<PdfObject>		ResObjects,		// list of resource objects for this contents
			Boolean				AddProcSet		// for page contents we need /ProcSet 
			)
		{
		// resource object list is empty
		// if there are no resources an empty dictionary must be returned
		if(ResObjects == null || ResObjects.Count == 0)
			{
			return(AddProcSet ? "<</ProcSet [/PDF/Text]>>" : "<<>>");
			}

		// resources dictionary content initialization
		StringBuilder Resources = new StringBuilder("<<");

		// for page object
		if(AddProcSet) Resources.Append("/ProcSet [/PDF/Text/ImageB/ImageC/ImageI]\n");

		// add all resources
		Char ResCodeType = ' ';
		foreach(PdfObject Resource in ResObjects)
			{
			// resource code is /Xnnn
			if(Resource.ResourceCode[1] != ResCodeType)
				{
				// terminate last type
				if(ResCodeType != ' ') Resources.Append(">>\n");

				// start new type
				ResCodeType = Resource.ResourceCode[1];
				Resources.Append(ResCodeStr[ResCodeLetter.IndexOf(ResCodeType)]);
				}
			// append resource code
			Resources.Append(String.Format("{0} {1} 0 R", Resource.ResourceCode, Resource.ObjectNumber));
			}

		// terminate last type and resource dictionary
		Resources.Append(">>\n>>");

		// exit
		return(Resources.ToString());
		}

	////////////////////////////////////////////////////////////////////
	// Write object to PDF file
	// Called by PdfDocument.CreateFile(FileName) method
	// to output one indirect PDF object.
	// It is a virtual method. Derived classes can overwrite it.
	////////////////////////////////////////////////////////////////////

	internal virtual void WriteObjectToPdfFile
			(
			BinaryWriter PdfFile		// output file
			)
		{
		// write object header
		PdfFile.Write(Encoding.ASCII.GetBytes(String.Format("{0} 0 obj\n", ObjectNumber)));

		// we have contents stream
		if(ContentsString != null && ContentsString.Length > 0)
			{
			// contents in bytes
			Byte[] ByteContents = new Byte[ContentsString.Length];

			// convert content from string to binary
			// do not use Encoding.ASCII.GetBytes(...)
			for(Int32 Index = 0; Index < ContentsString.Length; Index++) ByteContents[Index] = (Byte) ContentsString[Index];

			// if we have contents and dictionary we have a stream
			if(Dictionary != null)
				{
				// for testing compression is disabled
				if(!Document.Debug)
					{
					// compress stream
					Byte[] CompContents = CompressStream(ByteContents);
					if(CompContents != null)
						{
						ByteContents = CompContents;
						AddToDictionary("/Filter", "/FlateDecode");
						}
					}

				// encryption
				if(Document.Encryption != null) ByteContents = Document.Encryption.EncryptByteArray(ObjectNumber, ByteContents);

				// stream length
				Dictionary.Add(new PdfDictionary("/Length", ByteContents != null ? ByteContents.Length.ToString() : "0"));

				// write dictionary
				DictionaryToPdfFile(PdfFile);

				// write stream reserved word
				PdfFile.Write(Encoding.ASCII.GetBytes("stream\n"));

				// write content to pdf file
				if(ByteContents != null) PdfFile.Write(ByteContents);

				// write end of stream
				PdfFile.Write(Encoding.ASCII.GetBytes("\nendstream\n"));
				}

			// we have contents but no dictionary
			else
				{
				// write content to pdf file
				PdfFile.Write(ByteContents);
	
				// final terminator
				PdfFile.Write('\n');
				}
			}

		// no contents
		else
			{
			// we have a dictionary
			if(Dictionary != null)
				{
				// write dictionary
				DictionaryToPdfFile(PdfFile);
				}

			// no contents and no dictionary
			else
				{
				throw new ApplicationException("Empty object");
				}
			}

		// output object trailer
		PdfFile.Write(Encoding.ASCII.GetBytes("endobj\n"));

		// invoke garbage collector
		GC.Collect();
		return;
		}

	////////////////////////////////////////////////////////////////////
	// Compress byte array
	////////////////////////////////////////////////////////////////////
	
	protected Byte[] CompressStream
			(
			Byte[] InputBuf
			)
		{
		// input length
		Int32 InputLen = InputBuf.Length;

		// input buffer too small to compress
		if(InputLen < 16) return(null);

		// create output memory stream to receive the compressed buffer
		MemoryStream OutputStream = new MemoryStream();

		// deflate compression object
		DeflateStream Deflate = new DeflateStream(OutputStream, CompressionMode.Compress, true);

		// load input buffer into the compression class
		Deflate.Write(InputBuf, 0, InputBuf.Length);

		// compress, flush and close
		Deflate.Close();

		// compressed file length
		Int32 OutputLen = (Int32) OutputStream.Length;

		// make sure compressed stream is shorter than input stream
		if(OutputLen + 6 >= InputLen) return(null);

		// create output buffer
		Byte[] OutputBuf = new Byte[OutputLen + 6];

		// write two bytes in most significant byte first
		OutputBuf[0] = (Byte) 0x78;
		OutputBuf[1] = (Byte) 0x9c;

		// copy the compressed result
		OutputStream.Seek(0, SeekOrigin.Begin);
		OutputStream.Read(OutputBuf, 2, OutputLen);
		OutputStream.Close();

		// reset adler32 checksum
		UInt32 ReadAdler32 = Adler32Checksum(InputBuf);

		// ZLib checksum is Adler32 write it big endian order, high byte first
		OutputLen += 2;
		OutputBuf[OutputLen++] = (Byte) (ReadAdler32 >> 24);
		OutputBuf[OutputLen++] = (Byte) (ReadAdler32 >> 16);
		OutputBuf[OutputLen++] = (Byte) (ReadAdler32 >> 8);
		OutputBuf[OutputLen] = (Byte) ReadAdler32;

		// successful exit
		return(OutputBuf);
		}

	/////////////////////////////////////////////////////////////////////
	// Accumulate Adler Checksum
	/////////////////////////////////////////////////////////////////////

	private UInt32 Adler32Checksum
			(
			Byte[]		Buffer
			)
		{
		const UInt32 Adler32Base = 65521;

		// split current Adler checksum into two 
		UInt32 AdlerLow = 1; // AdlerValue & 0xFFFF;
		UInt32 AdlerHigh = 0; // AdlerValue >> 16;

		Int32 Len = Buffer.Length;
		Int32 Pos = 0;
		while(Len > 0) 
			{
			// We can defer the modulo operation:
			// Under worst case the starting value of the two halves is 65520 = (AdlerBase - 1)
			// each new byte is maximum 255
			// The low half grows AdlerLow(n) = AdlerBase - 1 + n * 255
			// The high half grows AdlerHigh(n) = (n + 1)*(AdlerBase - 1) + n * (n + 1) * 255 / 2
			// The maximum n before overflow of 32 bit unsigned integer is 5552
			// it is the solution of the following quadratic equation
			// 255 * n * n + (2 * (AdlerBase - 1) + 255) * n + 2 * (AdlerBase - 1 - UInt32.MaxValue) = 0
			Int32 n = Len < 5552 ? Len : 5552;
			Len -= n;
			while(--n >= 0) 
				{
				AdlerLow += (UInt32) Buffer[Pos++];
				AdlerHigh += AdlerLow;
				}
			AdlerLow %= Adler32Base;
			AdlerHigh %= Adler32Base;
			}
		return((AdlerHigh << 16) | AdlerLow);
		}

	////////////////////////////////////////////////////////////////////
	// Write dictionary to PDF file
	// Called from WriteObjectToPdfFile to output a dictionary
	////////////////////////////////////////////////////////////////////
	
	internal void DictionaryToPdfFile
			(
			BinaryWriter	PdfFile		// output file
			)
		{
		Int32 EolMarker = 100;
		StringBuilder Str = new StringBuilder("<<");

		// output dictionary
		foreach(PdfDictionary Dict in Dictionary)
			{
			// add new line to cut down very long lines
			if(Str.Length > EolMarker)
				{
				Str.Append("\n");
				EolMarker = Str.Length + 100;
				}

			// add key value pair
			if(Dict.Value[0] == '/' || Dict.Value[0] == '[' || Dict.Value[0] == '<' || Dict.Value[0] == '(')
				Str.AppendFormat("{0}{1}", Dict.Key, Dict.Value);
			else
				Str.AppendFormat("{0} {1}", Dict.Key, Dict.Value);
			}

		// terminate dictionary
		Str.Append(">>\n");

		// write to pdf file
		PdfFile.Write(Encoding.ASCII.GetBytes(Str.ToString()));
		return;
		}
	}

////////////////////////////////////////////////////////////////////
// Dictionary key value pair class
// Holds one key value pair
////////////////////////////////////////////////////////////////////

internal class PdfDictionary
	{
	internal String		Key;		// key first character must be forward slash ?
	internal String		Value;		// value associated with key

	////////////////////////////////////////////////////////////////////
	// Constructor
	////////////////////////////////////////////////////////////////////

	internal PdfDictionary
			(
			String		Key,		// key first character must be forward slash ?
			String		Value		// value associated with key
			)
		{
		if(Key[0] != '/') throw new ApplicationException("Dictionary key must start with /");
		this.Key = Key;
		this.Value = Value;
		return;
		}
	}
}
